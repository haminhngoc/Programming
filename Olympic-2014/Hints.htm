<!DOCTYPE html>
<html>
<body>
    <h1 id="2240">
        <a href="http://vn.spoj.com/problems/MYSTERY/">2240. Số huyền bí (Level 4)</a></h1>
    <div>
        <ul>
            <li>
                Tìm tất cả ước số của a (Độ khó 3, ref: 
                https://github.com/haminhngoc/Programming/blob/master/Ngoc/BaseCode/NumberAlgorithms.java)<ul>
                    <li>Phân tích thừa số nguyên tố</li>
                    <li>Tổ hợp thừa số này để tạo thành ước số</li>
                </ul>
            </li>
            <li>* Ước lớn nhất có thể là a/2 ~ 500M (maxP). Tổng số ước tối đa ~ 2^8 * 4 ~ 1K (Why?)</li>
            <li>* Trường hợp xấu nhất là gì? hãy đưa vào testcase để kiểm tra thời gian thực thi!</li>
            <li>Thời gian 1s, cho phép thử nghiệm giải pháp đơn giản: tính phần dư của 3^d chia cho M với độ phức tạp lg(maxP)
                (Độ khó 1)
                <ul>
                <li>Code?</li>
                    <li>Tính số dư của tích (3^d-1) với tối đa 1K ước số không cần thiết phải cải thiện</li>
                </ul>
            </li>
            <li>Cải tiến:<ul>
                <li>Xắp xếp ước theo thứ tự tăng dần, sử dụng kết quả trước đó để tính phần dư 3^d</li>
                <li>Sử dụng bộ đệm 1M phần tử lưu trữ tất cả kết quả đã tính</li>
                <li>=&gt; giảm 50% thời gian chạy (How?)</li>
                </ul>
            </li>
        </ul>
    </div>



    
    <h1>
        <a href="http://vn.spoj.com/problems/NKPALIN/">2118. Chuỗi đối xứng (Level 3+)</a></h1>
    <div>
        <ul>
            <li>Ý tưởng: Dynamic Programming tương tự bài chuỗi tăng dài nhất<ul>
                <li>Ref: Phi :)</li>
                </ul>
            </li>
        </ul>
    </div>


    



    
    <h1>
        <a href="http://vn.spoj.com/problems/NKSEQ/">2203. Dãy số (Level 5)</a></h1>
    <div>
        <ul>
            <li>Ý tưởng:
                <ul>
                    <li>Tận dụng tổng a1+a2...+ai (Được tính lần đầu tiên) để kiểm tra tất cả tổng có kết thúc tại i</li>
                    <li>Thay vì so sánh với 0 (Hằng số), ta so sánh với 0, a1, a1+a2... (hàm số)</li>
                    <li>Chỉ cần so sánh giá trị nhỏ nhất</li>
                </ul>
            </li>
            <li>Xét biến thể của cây <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL</a></li>
            <ul>
                <li>Mỗi Node có biến Count: Khi thêm một phần tử trùng => Count += 1</li>
                <li>Khi loại phần tử => Count -= 1. Khi Count == 0 => Loại node ra khỏi cây</li>
            </ul>
            <li>Add n giá trị sau vào cây: a1, a1+a2, a1+a2+a3..., sum(ai)</li>
            <li>Lấy giá trị nhỏ nhất so sánh vơi 0</li>
            <li>Tại bước thứ i:
                <ul>
                    <li>Đặt Si=a1+a2...+ai. Lấy phần tử Si ra khỏi cây</li>
                    <li>Thêm phần tử Sum + Si vào cây</li>
                    <li>Lấy giá trị nhỏ nhất so sánh với Si</li>
                </ul>
            </li>
            <li>Độ phức tạp: O(nlgn)</li>
        </ul>
    </div>


    



    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>


    



    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>


    



    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>

    <style>
        h1
        {
            margin-top: 20px;
        }
        
        body > div
        {
            padding-left: 20px;
        }
    </style>
</body>
</html>
