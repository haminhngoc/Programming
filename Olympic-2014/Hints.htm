<!DOCTYPE html>
<html>
<body>
    <h1 id="2240">
        <a href="http://vn.spoj.com/problems/MYSTERY/">2240. Số huyền bí (Level 4)</a></h1>
    <div>
        <ul>
            <li>
                Tìm tất cả ước số của a (Độ khó 3, ref: 
                https://github.com/haminhngoc/Programming/blob/master/Ngoc/BaseCode/NumberAlgorithms.java)<ul>
                    <li>Phân tích thừa số nguyên tố</li>
                    <li>Tổ hợp thừa số này để tạo thành ước số</li>
                </ul>
            </li>
            <li>* Ước lớn nhất có thể là a/2 ~ 500M (maxP). Tổng số ước tối đa ~ 2^8 * 4 ~ 1K (Why?)</li>
            <li>* Trường hợp xấu nhất là gì? hãy đưa vào testcase để kiểm tra thời gian thực thi!</li>
            <li>Thời gian 1s, cho phép thử nghiệm giải pháp đơn giản: tính phần dư của 3^d chia cho M với độ phức tạp log(maxP)
                (Độ khó 1)
                <ul>
                <li>Code?</li>
                    <li>Tính số dư của tích (3^d-1) với tối đa 1K ước số không cần thiết phải cải thiện</li>
                </ul>
            </li>
            <li>Cải tiến:<ul>
                <li>Xắp xếp ước theo thứ tự tăng dần, sử dụng kết quả trước đó để tính phần dư 3^d</li>
                <li>Sử dụng bộ đệm 1M phần tử lưu trữ tất cả kết quả đã tính</li>
                <li>=&gt; giảm 50% thời gian chạy (How?)</li>
                </ul>
            </li>
        </ul>
    </div>



    
    <h1>
        <a href="http://vn.spoj.com/problems/NKPALIN/">2118. Chuỗi đối xứng (Level 3+)</a></h1>
    <div>
        <ul>
            <li>Ý tưởng: Dynamic Programming tương tự bài chuỗi tăng dài nhất<ul>
                <li>Ref: Phi :)</li>
                </ul>
            </li>
        </ul>
    </div>


    



    
    <h1>
        <a href="http://vn.spoj.com/problems/NKSEQ/">2203. Dãy số (Level 5)</a></h1>
    <div>
        <h2>Solution 1: </h2>
        <ul>
            <li>* Russian Winter Training Camp 2004</li>
            <li>Ý tưởng:
                <ul>
                    <li>Tận dụng tổng a1+a2...+ai (Được tính lần đầu tiên) để kiểm tra tất cả tổng có kết thúc tại i</li>
                    <li>Thay vì so sánh với 0 (Hằng số), ta so sánh với 0, a1, a1+a2... (hàm số)</li>
                    <li>Chỉ cần so sánh giá trị nhỏ nhất</li>
                </ul>
            </li>
            <li>Xét biến thể của cây <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL</a></li>
            <ul>
                <li>Mỗi Node có biến Count: Khi thêm một phần tử trùng => Count += 1</li>
                <li>Khi loại phần tử => Count -= 1. Khi Count == 0 => Loại node ra khỏi cây</li>
            </ul>
            <li>Add n giá trị sau vào cây: a1, a1+a2, a1+a2+a3..., sum(ai)</li>
            <li>Lấy giá trị nhỏ nhất so sánh vơi 0</li>
            <li>Tại bước thứ i:
                <ul>
                    <li>Đặt Si=a1+a2...+ai = S(i-1) + ai. Lấy phần tử Si ra khỏi cây</li>
                    <li>Thêm phần tử Sum + Si vào cây</li>
                    <li>Lấy giá trị nhỏ nhất so sánh với Si</li>
                </ul>
            </li>
            <li>Độ phức tạp: O(nlogn)</li>
        </ul>
        
        <h2>Solution 2 (Phúc): DP</h2>
        <ul>
            <li></li>
        </ul>
        
        <h2>Solution 3: </h2>
        <ul>
            <li>* Solution 1 làm khá nhiều việc thừa :)</li>
            <li>Ý tưởng khác: với yêu cầu của đề bài, tại vị trí j nếu ta chỉ ra được một trường hợp đủ xấu thì không cần kiểm tra các tổng còn lại<ul>
                <li>Ví dụ: Nếu aj &lt;= 0 thì có thể loại bỏ j</li>
                </ul>
            </li>
            <li> Giải pháp:
                <ul>
                    <li>Bắt đầu ví trí j mà aj không dương và số bên phải của nó dương</li>
                    <li>Ta tính quay ngược về bên trái, tính tổng Sij = ai + a(i+1)...+aj, loại đi tất cả vị trí mà Sij không dương</li>
                    <li>Nếu i là số tận cùng bên trái bị loại => hoặc i quay lại vị trí j, hoặc S(i-1)k (k đi từ i đến j) là số dương (Vì 
                        S(i-1)k + Skj &gt; 0 &amp; Skj &lt;= 0)</li>
                    <li>Ta đã có đoạn dương (i-1)j =&gt; Được xem là một Node dương</li>
                    <li>Tiếp tục các bước dịch sang trái => Hoặc ta có M đoạn dương, hoặc có đoạn âm đủ lớn để triệt tiêu các đoạn dương đã tạo ra ở lần lặp lại thứ hai</li>
                    <li> => Kết quả là số Node dương còn lại</li>
                </ul>
            </li>
        </ul>
    </div>


    



    
    <h1>
        <a href="http://vn.spoj.com/problems/NKMAXSEQ/">2250. Dãy con dài nhất (Level 4)</a></h1>
    <div>
        <ul>
            <li>* Đề thi quốc gia 2006. Sự phức tạp là điều khó tránh :)</li>
            <li>Ý tưởng: 
                <ul>
                    <li>Xét dãy số sau: S0 = 0, S1=a1, S2=a1+a2...Sn=a1+a2...+an </li>
                    <li>=> Trọng lượng của dãy con [i,j] là Sj - S(i-1)</li>
                    <li>Với mỗi S(i-1) ta cần tìm chỉ số j lớn nhất sao cho Sj &gt;= S(i-1)+p</li>
                </ul>
            </li>
            <li>=&gt; Có thể đoán được cần sử dụng cấu trúc cây, để đảm bảo chạy được cho trường hợp xấu nhất =&gt; ta sử dụng cây nhị phân 
                cân bằng (AVL - giống bài ở trên)</li>
            <li>Biến thể Node như sau: Ngoài giá trị cần tìm, ta lưu chỉ số lớn nhất của giá trị lớn hơn hoặc bằng giá trị node hiện tại<ul>
                <li><img src="https://raw.githubusercontent.com/haminhngoc/Programming/master/Olympic-2014/Pictures/AVL-LastIndex.JPG" 
                        alt="./Pictures/AVL-LastIndex.JPG" style="height: 300px;" /> </li>
                <li>F(7) = F(4) = F(8) = F(9) = F(10) = 10, F(15) = 5</li>
                </ul>
            </li>
            <li>Độ phức tạp: Xây dựng cây AVL O(nlogn) + tìm kiếm O(nlogn)</li>
        </ul>

        <h4>Improvement: </h4>
        <ul>
            <li>Ý tưởng:<ul>
                <li>Không dùng Tree, sử dụng danh sách xắp xếp hợp lý</li>
                <li>* Có thể áp dụng cho các bài khác!</li>
                </ul>
            </li>
            <li>Tạo Node chứa chỉ số i và giá trị Si</li>
            <li>Xắp xếp tăng dần theo Si và i</li>
            <li>Duyệt từ cuối danh sách đã xắp xếp =&gt; Cập nhật chỉ số Node(i).Index = Max(Node(j).Index, Node(i+1).Index)</li>
        </ul>
    </div>


    



    
    <h1>
        <a href="http://vn.spoj.com/problems/NUCLEAR/">13019. Hai nhà máy điện nguyên tử (Level 5)</a></h1>
    <div>
        <ul>
            <li>* Pre VOI 2012 - Hai Phòng</li>
            <li>Những gia đình bị ảnh hưởng là tập: Uj(A, B) = Sj(A) + Sj(B) - Ij(A, B) => Hai vấn đề:
                <ul>
                    <li>Tổng số gia đình ảnh hưởng bởi A, và tổng số gia đình ảnh hưởng bởi B<ul>
                        <li>=&gt; Xắp xếp gia đình theo khoảng cách đến A =&gt; Tìm số gia đình bị ảnh hưởng bởi từng dự án =&gt; Độ phức tạp O(nlogn) (A*)</li>
                        <li>=&gt; Tương tự cho B</li>
                        </ul>
                    </li>
                    <li>Số gia đình ảnh hưởng bởi cả A và B (2)</li>
                </ul>
            </li>
            <li>Ý tưởng (2):&nbsp;
                <ul>
                    <li>Xắp xếp các dự án theo bán kính ảnh hưởng bởi A (Ra1 &lt;= Ra2 &lt;= Ra3...) =&gt; Cho phép khi ta tận dụng được một phần kết quả 
                        đã tính trước đó</li>
                    <li>Ta xét tất cả gđ trong A* bị ảnh hưởng bởi A trong dự án j (&lt;= Raj), kiểm tra có bao nhiêu gđ bị ảnh hưởng trong dự án 
                        này bởi B (&lt;= Rbj - Lưu ý Rbj không có thứ tự)</li>
                </ul>
            </li>
            <li>Giải pháp:<ul>
                <li>Giống như hai bài trên, ta sử dụng <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL</a> với khả năng trả lời có bao nhiêu node con bên phải hoặc bên trái</li>
                <li>Lần lượt thêm tất cả gđ có khoảng cách đến A không lớn hơn Raj vào cây - Node&#39;s value là khoảng cách đến B</li>
                <li>Hỏi xem có bao nhiêu node con có giá trị không lớn hơn Rbj</li>
                </ul>
            </li>
            <li>Độ phức tạp: O(nlogn)</li>
        </ul>

        <h4>Nếu muốn tránh AVL: </h4>
        <ul>
            <li>Ý tưởng:<ul>
                <li>Xắp xếp danh sách Rbj, xây dựng cây nhị phân từ chính giá trị Rbj</li>
                <li>E.g. BuildTree(n): Node((n+1)/2) {Left = BuildTree(0,(n+1)/2-1), Right = BuildTree((n+1)/2+1,n)}</li>
                <li>Mặc nhiên có cây cân bằng. Add(value) =&gt; Thay đổi CountLeft, CountRight của node tương ứng</li>
                </ul>
            </li>
        </ul>
    </div>


    



    
    <h1>Thảo luận</h1>
    <div>
        <ol>
            <li>Khánh và Sơn "có năng khiếu" chọn các bài khó :) => Có lẽ nên tránh các bài *OI</li>
            <li>AVL được sử dụng để tránh trường hợp xấu nhất trong cây nhị phân. Nếu có khả năng thêm các node vào một cách ngẫu nhiêu thì cũng không cần đến</li>
            <li>Những năm trước đây, có vẻ người ra đề thiên vị sử dụng cây nhị phân, giống như hiện nay là Segment/Interval/Fenwick Tree ... </li>
            <li>Hoặc là sau khi làm một bài có sử dụng AVL, có vẻ suy nghĩ bị thiên vị về hướng này. =&gt; Coi như là một giải pháp ban 
                đầu.</li>
            <li>=&gt; Các em trao đổi các giải pháp khác nữa nhé.</li>
        </ol>
    </div>


    
    <h1>
        <a href="http://vn.spoj.com/problems/VOSMUL/">21165. Sinh nhật của Benjamin (Level 3+)</a></h1>
    <div>
        <ul>
            <li>Bài này không quá khó, BruteForce và xử lý khéo trạng thái là đủ</li>
            <li>Khánh + Phi + Duy + Phúc: Thử làm đi nhé. Tuần sau sẽ trao đổi</li>
        </ul>
    </div>


    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>


    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>


    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>


    
    <h1>
        <a href=""></a></h1>
    <div>
        <ul>
            <li></li>
        </ul>
    </div>

    <style>
        h1
        {
            margin-top: 20px;
        }
        
        body > div
        {
            padding-left: 20px;
        }
    </style>
</body>
</html>
